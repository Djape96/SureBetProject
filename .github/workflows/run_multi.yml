name: Run multi script every 5 minutes (looped)

on:
  schedule:
    - cron: '*/5 * * * *'  # Every 5 minutes
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  actions: write  # needed for self-dispatch chaining

concurrency:
  group: run-multi
  cancel-in-progress: true

jobs:
  run-multi:
    runs-on: ubuntu-latest
    timeout-minutes: 350  # Max practical job length (~6h) for near-continuous looping
    env:
      TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
      TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Fail-fast secrets check
        run: |
          [ -z "$TELEGRAM_BOT_TOKEN" ] && echo "Missing TELEGRAM_BOT_TOKEN secret" && exit 1 || echo "TELEGRAM_BOT_TOKEN present"
          [ -z "$TELEGRAM_CHAT_ID" ] && echo "Missing TELEGRAM_CHAT_ID secret" && exit 1 || echo "TELEGRAM_CHAT_ID present"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies (if requirements.txt exists)
        if: hashFiles('requirements.txt') != ''
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Long-running loop
        env:
          LOOP_SLEEP_SECONDS: 60
          MAX_MINUTES: 330  # safety buffer before timeout
        run: |
          echo "Starting long loop at $(date -u) UTC"; start_ts=$(date +%s)
          set -o pipefail
          cycle=0
          while true; do
            now=$(date +%s)
            elapsed=$(( (now - start_ts) / 60 ))
            if [ $elapsed -ge $MAX_MINUTES ]; then echo "Reached MAX_MINUTES ($MAX_MINUTES). Exiting loop."; break; fi
            cycle=$((cycle+1))
            echo "=== Cycle $cycle (elapsed ${elapsed}m) $(date -u) ==="
            python run_multi.py --sequential --no-aggregate || echo "Cycle $cycle failed (continuing)"
            echo "Sleeping ${LOOP_SLEEP_SECONDS}s..."; sleep $LOOP_SLEEP_SECONDS
          done 2>&1 | tee run_multi.log

      - name: Dispatch next run (chain)
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const workflow_id = 'run_multi.yml';
            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id,
              ref: '${{ github.ref_name }}'
            });
            core.info('Queued next workflow run for continuous execution.')

      - name: List files after run
        if: always()
        run: |
          echo "Workspace contents:";
          ls -al . | head -100; echo "Logs dir (if any):"; ls -al logs || true; echo "Show log tail:"; tail -n 40 run_multi.log || echo "run_multi.log missing"

      - name: Upload run log artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: run_multi_log
          path: run_multi.log
          retention-days: 7

      - name: Create issue on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const runId = process.env.GITHUB_RUN_ID;
            const sha = process.env.GITHUB_SHA;
            const repo = context.repo;
            const url = `https://github.com/${repo.owner}/${repo.repo}/actions/runs/${runId}`;
            const title = `run_multi failure ${new Date().toISOString()}`;
            const body = `Workflow run failed.\nRun: ${url}\nCommit: ${sha}\nPlease inspect the artifact log for details.`;
            await github.rest.issues.create({
              owner: repo.owner,
              repo: repo.repo,
              title,
              body
            });

      - name: Post-run summary
        if: always()
        run: |
          echo "Completed with conclusion: ${{ job.status }}"